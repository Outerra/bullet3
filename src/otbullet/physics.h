
#ifndef __INTERGEN_GENERATED__physics_H__
#define __INTERGEN_GENERATED__physics_H__

//@file Interface file for physics interface generated by intergen

#include <comm/commexception.h>
#include <comm/intergen/ifc.h>

#include "physics_cfg.h"

class btDynamicsWorld;
class btCollisionShape;
class btCompoundShape;
class btCollisionObject;
class btRigidBody;
class btActionInterface;
class btTransform;

namespace bt {
    class constraint_info;
    class physics;
}
extern bt::physics* BT;

class physics;


namespace bt {

////////////////////////////////////////////////////////////////////////////////
///Interface for physics module
class physics
    : public intergen_interface
{
public:

    // --- interface methods ---

    void step_simulation( double step );

    void ray_test( const double from[3], const double to[3], void* cb );

    btRigidBody* fixed_object();

    btRigidBody* create_rigid_body( float mass, btCollisionShape* shape, void* usr1, void* usr2 );

    void destroy_rigid_body( btRigidBody*& obj );

    void add_rigid_body( btRigidBody* obj, unsigned int group, unsigned int mask, btActionInterface* action, bt::constraint_info* constraint );

    void remove_rigid_body( btRigidBody* obj, btActionInterface* action, bt::constraint_info* constraint );

    void pause_rigid_body( btRigidBody* obj, bool pause );

    void set_rigid_body_mass( btRigidBody* obj, float mass, const float inertia[3] );

    void set_rigid_body_gravity( btRigidBody* obj, const double gravity[3] );

    void set_rigid_body_transform( btRigidBody* obj, const btTransform& tr, const double gravity[3] );

    void predict_rigid_body_transform( btRigidBody* obj, double dt, ifc_out btTransform& tr );

    btCollisionObject* create_collision_object( btCollisionShape* shape, void* usr1, void* usr2 );

    void destroy_collision_object( btCollisionObject*& obj );

    void update_collision_object( btCollisionObject* obj, const btTransform& tr, bool update_aabb );

    void add_collision_object( btCollisionObject* obj, unsigned int group, unsigned int mask, bool inactive );

    void remove_collision_object( btCollisionObject* obj );

    btCompoundShape* create_compound_shape();

    void add_child_shape( btCompoundShape* group, btCollisionShape* child, const btTransform& tr );

    void update_child( btCompoundShape* group, int index, const btTransform& tr );

    void recalc_compound_shape( btCompoundShape* shape );

    void destroy_compound_shape( ifc_inout btCompoundShape*& shape );

    btCollisionShape* create_shape( bt::EShape sh, const float hvec[3] );

    void add_convex_point( btCollisionShape* shape, const float point[3] );

    void close_convex_shape( btCollisionShape* shape );

    void destroy_shape( ifc_inout btCollisionShape*& shape );

    // --- creators ---

    static iref<physics> create( double r ) {
        return create<physics>(0, r);
    }

    template<class T>
    static iref<T> create( T* _subclass_, double r );
    static iref<physics> get() {
        return get<physics>(0);
    }

    template<class T>
    static iref<T> get( T* _subclass_ );

    // --- internal helpers ---

    static const int HASHID = 2201364551;
    
    int intergen_hash_id() const override { return HASHID; }
    
    const coid::token& intergen_interface_name() const override {
        static const coid::token _name = "bt::physics";
        return _name;
    }

    const coid::token& intergen_default_creator() const override {
        static const coid::token _dc("bt::physics.get@2201364551");
        return _dc;
    }

    void* intergen_wrapper_js() const override {
        static void* _js_create_wrapper=0;
        if(_js_create_wrapper)
            return _js_create_wrapper;

        static const coid::token _js_wrapper_key = "bt::js::physics@wrapper";
        _js_create_wrapper = coid::interface_register::get_interface_creator(_js_wrapper_key);
        return _js_create_wrapper;
    }
    
protected:

    physics()
    {}
};

////////////////////////////////////////////////////////////////////////////////
template<class T>
inline iref<T> physics::create( T* _subclass_, double r )
{
    typedef iref<T> (*fn_creator)(physics*, double);

    static fn_creator create = 0;
    static const coid::token ifckey = "bt::physics.create@2201364551";

    if(!create)
        create = reinterpret_cast<fn_creator>(
            coid::interface_register::get_interface_creator(ifckey));

    if(!create)
        throw coid::exception("interface creator inaccessible: ") << ifckey;

    return create(_subclass_, r);
}
////////////////////////////////////////////////////////////////////////////////
template<class T>
inline iref<T> physics::get( T* _subclass_ )
{
    typedef iref<T> (*fn_creator)(physics*);

    static fn_creator create = 0;
    static const coid::token ifckey = "bt::physics.get@2201364551";

    if(!create)
        create = reinterpret_cast<fn_creator>(
            coid::interface_register::get_interface_creator(ifckey));

    if(!create)
        throw coid::exception("interface creator inaccessible: ") << ifckey;

    return create(_subclass_);
}


inline void physics::step_simulation( double step )
{ return VT_CALL(void,(double),0)(step); }

inline void physics::ray_test( const double from[3], const double to[3], void* cb )
{ return VT_CALL(void,(const double[3],const double[3],void*),1)(from,to,cb); }

inline btRigidBody* physics::fixed_object()
{ return VT_CALL(btRigidBody*,(),2)(); }

inline btRigidBody* physics::create_rigid_body( float mass, btCollisionShape* shape, void* usr1, void* usr2 )
{ return VT_CALL(btRigidBody*,(float,btCollisionShape*,void*,void*),3)(mass,shape,usr1,usr2); }

inline void physics::destroy_rigid_body( btRigidBody*& obj )
{ return VT_CALL(void,(btRigidBody*&),4)(obj); }

inline void physics::add_rigid_body( btRigidBody* obj, unsigned int group, unsigned int mask, btActionInterface* action, bt::constraint_info* constraint )
{ return VT_CALL(void,(btRigidBody*,unsigned int,unsigned int,btActionInterface*,bt::constraint_info*),5)(obj,group,mask,action,constraint); }

inline void physics::remove_rigid_body( btRigidBody* obj, btActionInterface* action, bt::constraint_info* constraint )
{ return VT_CALL(void,(btRigidBody*,btActionInterface*,bt::constraint_info*),6)(obj,action,constraint); }

inline void physics::pause_rigid_body( btRigidBody* obj, bool pause )
{ return VT_CALL(void,(btRigidBody*,bool),7)(obj,pause); }

inline void physics::set_rigid_body_mass( btRigidBody* obj, float mass, const float inertia[3] )
{ return VT_CALL(void,(btRigidBody*,float,const float[3]),8)(obj,mass,inertia); }

inline void physics::set_rigid_body_gravity( btRigidBody* obj, const double gravity[3] )
{ return VT_CALL(void,(btRigidBody*,const double[3]),9)(obj,gravity); }

inline void physics::set_rigid_body_transform( btRigidBody* obj, const btTransform& tr, const double gravity[3] )
{ return VT_CALL(void,(btRigidBody*,const btTransform&,const double[3]),10)(obj,tr,gravity); }

inline void physics::predict_rigid_body_transform( btRigidBody* obj, double dt, btTransform& tr )
{ return VT_CALL(void,(btRigidBody*,double,btTransform&),11)(obj,dt,tr); }

inline btCollisionObject* physics::create_collision_object( btCollisionShape* shape, void* usr1, void* usr2 )
{ return VT_CALL(btCollisionObject*,(btCollisionShape*,void*,void*),12)(shape,usr1,usr2); }

inline void physics::destroy_collision_object( btCollisionObject*& obj )
{ return VT_CALL(void,(btCollisionObject*&),13)(obj); }

inline void physics::update_collision_object( btCollisionObject* obj, const btTransform& tr, bool update_aabb )
{ return VT_CALL(void,(btCollisionObject*,const btTransform&,bool),14)(obj,tr,update_aabb); }

inline void physics::add_collision_object( btCollisionObject* obj, unsigned int group, unsigned int mask, bool inactive )
{ return VT_CALL(void,(btCollisionObject*,unsigned int,unsigned int,bool),15)(obj,group,mask,inactive); }

inline void physics::remove_collision_object( btCollisionObject* obj )
{ return VT_CALL(void,(btCollisionObject*),16)(obj); }

inline btCompoundShape* physics::create_compound_shape()
{ return VT_CALL(btCompoundShape*,(),17)(); }

inline void physics::add_child_shape( btCompoundShape* group, btCollisionShape* child, const btTransform& tr )
{ return VT_CALL(void,(btCompoundShape*,btCollisionShape*,const btTransform&),18)(group,child,tr); }

inline void physics::update_child( btCompoundShape* group, int index, const btTransform& tr )
{ return VT_CALL(void,(btCompoundShape*,int,const btTransform&),19)(group,index,tr); }

inline void physics::recalc_compound_shape( btCompoundShape* shape )
{ return VT_CALL(void,(btCompoundShape*),20)(shape); }

inline void physics::destroy_compound_shape( btCompoundShape*& shape )
{ return VT_CALL(void,(btCompoundShape*&),21)(shape); }

inline btCollisionShape* physics::create_shape( bt::EShape sh, const float hvec[3] )
{ return VT_CALL(btCollisionShape*,(bt::EShape,const float[3]),22)(sh,hvec); }

inline void physics::add_convex_point( btCollisionShape* shape, const float point[3] )
{ return VT_CALL(void,(btCollisionShape*,const float[3]),23)(shape,point); }

inline void physics::close_convex_shape( btCollisionShape* shape )
{ return VT_CALL(void,(btCollisionShape*),24)(shape); }

inline void physics::destroy_shape( btCollisionShape*& shape )
{ return VT_CALL(void,(btCollisionShape*&),25)(shape); }

} //namespace

#endif //__INTERGEN_GENERATED__physics_H__
